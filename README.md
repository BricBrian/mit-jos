# OS Lab4 实验报告

一、	实验准备

本次试验在Lab3基础上进行操作，在了解了用户进程相关知识后，对本次试验进行多次尝试，并结合网上内容，完成本次试验。
依旧存在合并错误，在pmap.c和trap.c中，出现了合并错误，删除掉合并错误的乱码。
随后，在第一次make qemu中，不知道为什么，kern无发生成一个叫sendpage的文件，无奈之下，只好从网上下载了一份sendpage.c文件，放进user目录下，然后开始第四次实验。

二、	实验过程

PART A

练习1:

lapic_init()一开始调用mmio_map_region()函数，为了实现虚拟地址和物理地址的分配，所以必然会调用boot_map_region()。返回kern/pmap.c，查看该函数定义，进行一个简单分配。其次，根据注释要求，要将size大小roundup PGSIZE，如果超过MMIOLIM，简单的panic，另外设置的page的权限是PTE_PCD|PTE_PWT|PTE_W，代码如下：
 

练习2:

通过阅读两个函数，大概了解程序运行过程：
	首先是I386_init()再完成一切初始化后，调用boot_aps();
	随后boot_aps()把每个CPU代码复制到指定位置；
	最后lapic_startap()来开始每一段CPU。
整个过程都是在CPU0上，也就是BSP上完成的。

修改代码只是在page_init()时候，不要把MPENTRY_PADDR(0x7000)加入到free_page_list中去，所以只需要一个条件语句进行判断即可，代码如下：
 
结果通过check_page_free_list()，在check_kern_pgdir()中报错，结果如图：
 

问题1:

逐行比较kern/mpentry.S和boot/boot.S。牢记kern/mpentry.S和其他内核代码一样也是被编译和链接在KERNBASE之上运行的。那么，MPBOOTPHYS这个宏定义的目的是什么呢？为什么它在kern/mpentry.S中是必要的，但在boot/boot.S却不用？换句话说，如果我们忽略掉kern/mpentry.S哪里会出现问题呢？ 提示：回忆一下我们在 Lab 1 讨论的链接地址和装载地址的不同之处。
答：观察mpentry.S，中有这样一段话：
 
所以，使用MPBOOTPHYS是为了获得其他变量的物理地址，因为实模式无法寻址在高地址，但是boot.s本身就是实模式可以寻址的低地址，不需要再转换成物理地址。

练习3:

这段代码只需要建立一个循环，依次为每个CPU用boot_map_region分配内核栈，值得注意的是，需要在KSTKGAP这段空间流出空间以防止两个CPU内核栈相互覆盖，NCPU代表CPU个数，权限kernel RW。所以代码如下：
 
成功通过check_kern_pgdir(),结果如图:
 
可以发现，程序报错，内核页发生缺页。目前尚不知原因。

练习4:

阅读trap_init_percpu()，发现由于以前的代码只能适用于单CPU情况，可以通过thiscpu来访问当前CPU，cpuid或者cpunum()获得当前id。随后依次初始化内核栈的esp,ss,tss。代码如下：
 
随后输入make qemu CPUS=4，获得以下结果：
 
CPU1，2，3依次启动，依旧会有内核页缺页报错。

练习5:

加锁的位置，前三个代码基本已经给定位置，至于释放锁的位置，当当前CPU释放，所以当寄存器存入现在环境，随后释放锁，代码如下：
 
值得注意的是，在mp_main()添加锁的同时，需要注释掉for(;;);这个死循环，因为不再需要。

问题2:

看起来使用全局内核锁能够保证同一时段内只有一个 CPU 能够运行内核代码。既然这样，我们为什么还需要为每个 CPU 分配不同的内核堆栈呢？请描述一个即使我们使用了全局内核锁，共享内核堆栈仍会导致错误的情形。

答：如果CPU1进入内核，压入数据后，让CPU2进入内核，就可能占据CPU1存放数据的地方，当CPU2解锁，CPU1在进入内核，就无法使用上次压入的数据。而是使用CPU2压入的数据，会造成结果混乱。

练习6:

首先，我们按照要求完成sched_yield()，寻找一个可运行的环境，如果，没有可运行环境，判断当前环境是否可运行，代码如下：
 
随后在系统调用中加上轮转调度，代码如下：
 
在init.c中删除旧的环境，添加三个新的环境，代码如下：
 
结果如图：
 

问题3:

在你实现的 env_run() 中你应当调用了 lcr3()。在调用 lcr3() 之前和之后，你的代码应当都在引用变量 e，就是 env_run() 所需要的参数。 在装载 %cr3 寄存器之后， MMU 使用的地址上下文立刻发生改变，但是处在之前地址上下文的虚拟地址（比如说 e ）却还能够正常工作，为什么 e 在地址切换前后都可以被正确地解引用呢？

答：因为当前是运行在系统内核中的，所有的进程env_pgdir的高地址的映射跟kern_pgdir的是一样的，每个进程页表中虚拟地址高于UTOP之上的地方，只有UVPT不一样，其余的都是一样的，只不过在用户态下是看不到的。所以虽然这个时候的页表换成了下一个要运行的进程的页表，但是curenv的地址没变，映射也没变。

问题4:

无论何时，内核在从一个进程切换到另一个进程时，它应当确保旧的寄存器被保存，以使得以后能够恢复。为什么？在哪里实现的呢？

答：因为通过保存状态，才能保证下次恢复到正确的环境，否则不知道该从哪里进行，通过trap()把用户态陷入内核态时候，curenv->env_tf = *tf这句话把状态保存到用户环境env_tf中。

练习7:

sys_exofork():
该函数的目的是为了创建子进程，如果错误了返回错误码，如果在父进程中，返回子进程id，如果是子进程调用返回0，在创造过程中，寄存器等于当前进程，状态改为not runnable，通过把eax该为0，系统调用返回值为0。代码如下：
 

sys_env_set_status():
该函数的目的就是更改制定id进程的状态，所以先用envid2env()转换id成进程，随后通过权限1以及判定目的是否处于可更改状态runnable或者not_unrunnable。代码如下：
 

sys_page_alloc():
该函数目的就是分配物理页，并且分配虚拟内存映射，首先我们将要分配的进程id转换为具体的环境，方法同上，其次要求必要权限是PTE_U|PTE_P，如果权限不够，返回-E_INVAL，如果都成功，用page_alloc()分配，如果没有内存，返回-E_NO_MEM。如果insert没有成功，free掉page。代码如下：
 

sys_page_map():
该函数目的为了给两个进程共享内存，首先通过id寻找到两个进程，随后跟前面函数一样，直到通过lookup找到确定的一个内存，把dst用insert存入。代码如下：
 

sys_page_unmap():
该函数目的是释放映射关系，依旧先通过具体的id找到环境，然后用remove，释放掉，代码如下：
 

随后，将函数对应到syscall里，代码如下：
 
至此，part A全部完成，make grade后结果：
 


PART B

练习8：

该题主要是实现函数sys_env_set_pgfault_upcall()，只需要找到对应环境，把他的env_pgfault_upcall改成func即可，代码如下：
 
随后，添加系统调用。

练习9:

该函数根据指导书中所写，应该分为两种情况，一种是正常情况下的，会导致内核构造一个UTrapframe，随后陷入异常处理栈；另一种情况是已经在异常栈，那么会在自己的esp上构造，但首先要先压入一个32位空值，也就是4字节。随后使用user_mem_assert()对异常栈进行overflow的检查，如果发生这种情况，就会发生内核缺页，会进行panic，该函数如果不通过检查，destroy环境，如果是当前环境，则不返回。所以如果通过检查，保存内陷的信息。随后把页面错误处理函数赋值给eip，并切回到用户态处理错误。代码如下：
 

练习10:

对于这部分代码，根据注释，可知之前嵌套中留下4字节，就是为了在每一个UTrapframe栈顶存储eip，方便这里返回，所以只需要在常规用户栈减去4字节，把这个eip取出来；随后依次还原通用寄存器和eflags；将栈顶弹到esp，此时esp存储的就是eip；弹出栈顶元素并返回。代码如下：
 

练习11:

这部分代码很简单，主要实现了先分配一个异常栈，然后调用sys_env_set_pgfault_upcall(),如果失败，进行简单的报错，代码如下：
 
几个结果如下：
make run-faultread:
 

make run-faultdie:
 

make run-faultalloc:
 

make run-faultallocbad:
 
至于为什么faultalloc和faultallocbad为什么会有不同，通过看了测试代码，发现唯一不同在于前者用了printf，后者用的是sys_puts。而printf虽然最后也会调用sys_puts，但他会先讲信息存入到缓存区，这是已经访问错误地址，而不会等到sys_puts再调用user_mem_check检查内存地址的正确性。所以，输出会有区别。

练习12:

通过理解UVPD和UVPT大概理解为，正常寻址可以寻址到具体的值，但是通过这两种寻址，通过一个指向自己的指针，消耗CR3的寻址，最后只能寻找到页目录或者二级页表。所以我们通过这种方式对以下函数进行更改。
 

pgfault（）：
首先按照注释，要求检查缺页操作是不是写操作，以及是否标记为COW，如果不是就panic。如果通过检查，分配一个新的页面，随后对这个页面进行指导书上的更改，代码如下：
 

duppage():
该函数的目的就是通过判断旧页面是否是wirte或者woc后，将新的页面改成woc，同时再将旧的页面也改成woc。代码如下：

 

fork():
按照指导书上步骤，依次完成程序：利用set_page_fault()创建pgfault()；然后利用sys_exofork()创建子进程，随后遍历每一个页面，调用duppage()，因为在该函数已经相信测定，再分配页面和创建异常栈，随后把状态改为runnable。代码如下：
 
利用make run-forktree，进行测试，结果如下：
 
最后，利用make grade进行测试，完成part B，结果如下：
 

PART C

练习13：

对于trapentry.S和trap.c处理的办法类似于LAB 3中的处理方式，代码如下： 
 

 

随后修改kern/env.c中env_alloc()，IDT表项中的每一项都初始化为中断门，这样在发生任何中断/异常的时候，陷入内核态的时候，CPU都会将%eflags寄存器上的FL_IF标志位清0，关闭中断；切换回用户态的时候，CPU将内核栈中保存的%eflags寄存器弹回%eflags寄存器，恢复原来的状态。所以在env.c中找到一句注释Enable interrupts while in user mode.所以在这个地方把eflags改为FL_IF，代码如下：
 

练习14：

这个也等同于以前，直接加一个判断语句即可，代码如下：
 
随后运行spin，成功结束程序，结果如图：
 
随后测试forktree，没有杀死正常进程。

练习15：

sys_ipc_recv():
根据注释我们可以知道，如果dstva < UTOP，但是dstva没有页对齐，返回-E_INVAL。如果满足，更改env_ipc_recving和env_ipc_dstva，并把状态改成not runnable。代码如下：
 
sys_ipc_try_send():
首先是判断能否通过id找到环境；环境是否愿意接受；如果srcva<UTOP，判断是否对齐，然后开始寻找页面，然后判断页面是否存在，权限的问题，如果一切都可以，那么用insert把这个页面加到指定环境中去。然后更新环境数据。代码如下：
 

ipc_send():
根据注释，如果是空页面，我们可以传递UTOP，这样sys_ipc_try_send()就不会传递页面。随后进入循环，不停调用sys_ipc_try_send()，直到收刀，如果收到错误信息回复，则panic。代码如下：
 
ipc_recv():
同样，如果是空页，传递UTOP，如果接受成功，更新数据，如果最后from_env_store和perm_store不为空，那么存储发送方的数据，最后又数据返回数据，没数据返回0。代码如下：
 

	最后，开始测试：
	pingpong：
 
	primes：分配到超出整个内存
 
三、	实验结果

最后通过make grade完成全部实验，结果如下：
 
通过本次试验加深了对抢占式多任务处理的理解。以及通讯和父子进程已经时钟等的认识。

